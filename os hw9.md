<script type="text/x-mathjax-config">
  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
</script>
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML">
</script>

# 第九次作业

## 3.7

（假设TLB在程序开始时不包含任何有效内容，且M、N都是正整数）

a)  

① 若$N = 1$  
则M取任何值都满足题意；  

② 若$N \ne 1$  
则若$M >= N$，则与①同理可知此解符合题意；

③ 若$N \ne 1 \land M < N$  
则需要保证任意连续的两次访存都会访问不同的页面。此时必须有$M \ge 1024$。  
而只要$M \ge 1024$，由于这些页面的页表项在程序开始之前并不在TLB中，故程序内层循环的访存是第一次访问这些页面，故一定会造成不命中。于是只须$M \ge 1024$。

综上，所求解为：  
$N = 1 \lor (N \ne 1 \land M \ge N) \lor (N \ne 1 \land M < N \land M > 1024)$

即：

$N \le M \lor M \ge 1024$

b)

不同。  
设$N = 2048, M = 1024$，则易知这是a)的一个解。但若重复执行两次此程序，则第二次不会产生TLB失效。

由a)的推导过程可知，第一次访问失效是因为页表项不曾在TLB中存在过。而只要保证这些页表项在第一次访问后仍在TLB中就可以保证第二次访问不失效。此时若要第二次（以及以后）失效，需在a)的基础上保证表项在下一次执行循环时被引用之前就被换出TLB。

## 3.9

装入页表的耗时为：

$\(100 \times 2^{32}) \div (2^{13}) = 52,428,800ns = 52.4288ms$

故用于装入页表的CPU时间的比例是52.4288%。

## 3.15

解不等式：

$5p + (1 - p) < 2$

得：

$p < 0.25$

即命中率应不小于75%。

## 3.19

散列表的长度应当大于系统中可用的总物理页面数。

物理页面数为：

$\(256 \times 2^{20})) \div (8 \times 2^{20}) = 32$

按照题意，散列表大小应当是大于32的2的整数次幂中最小的数，即64。

## 3.21

a)  
因为这些页面置换算法总希望将最近未使用的页面替换出去。  
第二次遍历序列时，命中数的上确界为系统中的物理页面总数。若要达到这个上界，系统中当前的所有物理页面都是最近将要访问的页面(号码最小的页面)，但由于它们“很久”没有被访问，替换算法已经将它们替换。所以实际上最好情况不能达到。更加坏的情况是，由于新的页面被载入时，仍然会替换之前最老的页面，以LRU为例，这实际上会造成所有访问全部缺页。

b)  
以a)中的结论为基础，为了使序列的命中数最大，我们得出如下的分配算法(MRU)：

> 在缺页发生时：
>
> ① 如果有空闲页，则分配空闲页。  
> ② 如果没有空闲页，分配最后一次被分配的空闲页。

记系统中物理页面总数为$n$，此时序列命中数为$n - 1$。这是最优的(因为总会有一个本来可以被命中的页最终被替换出去)。

考虑序列外的随机页码，由题可知两个序列之间至多有一个随机页码。理论上只要物理页面被填满，那么随机页码的命中期望就是相同的。于是所有合理的分配算法在随机页码的命中率上都相同。

进一步考虑随机页码对序列命中数的影响。使用MRU时，序列命中数至少是$n - 1$，这是因为本来命中的情况不受影响。若随机页码恰好是序号为n的页面，则序列命中数为$n$。

由此可见，MRU算法在此情况下是最优的，在a)中已经证明LRU，FIFO，Clock算法不是最优，故MRU算法是符合题意的算法。

## 3.24

时钟周期 |R位      |页框0    |页框1   |页框2    |页框3
--------|--------|--------|--------|--------|--------
0       |0111    |0XXXXXXX|1XXXXXXX|1XXXXXXX|1XXXXXXX
1       |1011    |10XXXXXX|01XXXXXX|11XXXXXX|11XXXXXX
2       |1010    |110XXXXX|001XXXXX|111XXXXX|011XXXXX
3       |1101    |1110XXXX|1001XXXX|0111XXXX|1011XXXX
4       |0010    |01110XXX|01001XXX|10111XXX|01011XXX
5       |1010    |101110XX|001001XX|110111XX|001011XX
6       |1100    |1101110X|1001001X|0110111X|0001011X
7       |0001    |01101110|01001001|00110111|10001011

第7周期的结果即为所求。

## 4.11

单个文件：

$(5ms + 4ms + 8KB \div 8MB/s) \times 2 = 20ms$

紧缩磁盘的一半：

若基于单个文件复制：  
$20ms \times (16GB \div 2 \div 8KB) = 20,971,520ms$

若基于连续复制：  
$(5ms + 4ms + (16GB \div 2 \div 8MB/s)) \times 2 = 2,048,018ms$

## 4.16

假设*文件属性*项之中有一个位标注此文件是否是一个小文件，并记块地址项的长度是$n$字节。

那么可以存放$8n$字节的数据。

若假设不成立，则需要在第一个块地址中存放一个特殊的值以表明它是一个小文件，记需要使用的存储量为$m$字节，则只能存储$8n-m$字节。

## 4.17

后者对。首先内核的内存资源是非常有限而宝贵的，即前提“存储器正变得廉价”根本不成立。就算前提成立，这种机制会使得任何程序不能独占文件。这会造成严重的读写冲突，且在这种情况下程序在运行时生成的临时文件可能被篡改，从而导致程序出错(且程序不能以任何形式预防此种情况的发生)。

## 4.21

会使得磁盘在分配新的磁盘块时行为异常。  

对于UNIX：

此情况可以恢复(可能是部分恢复)。  
恢复策略为：将所有块标记为未使用，之后根据存在的inode找到所有被使用的磁盘块，并将之标记为已使用，并暂存引用此块的inode。若发现某将要被标记的块是已使用的，则找到引用该块的inode，删除引用并标记此块是“危险的”，若发现某将要被标记的块是危险的，则忽略此块。此过程完成之后，将所有“危险的”块标记为未使用，并遍历inode表，若inode的数据块引用之中有空洞(即被删除的“危险”的块)，则紧缩inode的数据块引用。

上述恢复策略运行完成之后即完成恢复，此恢复算法保证恢复后的文件系统可以正常运行，但一些文件的信息可能丢失(因为它们使用了一些“危险的”块)。

对于FAT-16：

此情况不能恢复。

## 4.30

由于表项值有4个特殊值(未使用、坏簇、系统保留、最后一簇)，且0和1两个簇是保留的，故文件最多能使用32762个簇。

此时文件大小为：

$32KB * 32762 = 1,048,384KB$

## 4.34

优点：不固定inode的数量，可以用更多的空间存储有效数据。遍历inode列表较快(连续读取)。

缺点：目录项不能存储inode号而需要存储块号(需要更大的字长)，这会使得目录变大。且系统遍历所有inode的时间复杂度会变成文件数*文件平均目录层次深度，若考虑文件被组织成一个至多k叉的树结构，文件有n个，则时间复杂度不低于$O(n^2/k)$(略去推导过程)，且在常数系数中需要计入磁盘寻道与旋转等时间。

## 补充题

> **题面:** 某虚拟文件系统空间的最大容量为16TB，磁盘块（基本分配单位）大小为2KB。文件控制块（FCB）包含一个512B主索引表。请回答下列问题。  
> （1）假设主索引表只采用直接索引结构，主索引表中保存文件占用的磁盘块号。主索引表表项最少要占多少字节？可支持的单个文件最大长度是多少字节？  
> （2）假设主索引表采用如下结构：第0～11字节采用<起始块号，块数>的格式，表示文件创建时连续分配给文件的磁盘空间。其中起始块号占6B、块数占6B，剩余500B采用直接索引结构，一个索引项占6B。试问，采用这种结构可支持的单个文件的最大长度是多少字节？为了使单个文件的长度达到最大，起始块号和块数k分别所占的合理字节数是多少？请说明理由。

系统中共有$16TB \div 2KB = 2^{33}$个虚拟块。

(1)  
由以上分析，表项至少须用33个位保存块号。故最小要占5字节。考虑将所有空间用于存储表项，可支持的最大文件长度为

$(512B \div 5B) \times 2KB = 220KB$

(2)  
由于48位可表示的块数超过了虚拟文件系统空间中可保有的块总量，故最多只能使文件长度达到16TB。

只要块数至少占5个字节，就会使可表示的最大块数大于可保有的最大块数。而块号至少要占5个字节。只需满足上述两个条件即可。
